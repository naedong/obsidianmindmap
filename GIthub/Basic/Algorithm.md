
# DP 

## 개념 

|**종류**|**특징**|**장점**|**단점**|
|---|---|---|---|
|**탑다운(Top-Down) 방식**|큰 문제를 해결하기 위해 작은 문제를 호출하는 방식|작은 문제들의 결과값을 저장함으로써 동일한 계산을 반복하지 않아 시간 복잡도 감소합니다.|스택 오버플로우 발생 가능성이 있습니다.|
|**바텀업(Bottom-Up) 방식**|작은 문제부터 차례대로 해결해 나가는 방식|부분 문제의 해를 저장하고 이를 활용하여 다음 문제를 해결함으로써 시간 복잡도 감소합니다.|초기값을 설정해줘야 하고, 작은 문제들의 결과값을 임시적으로 저장해 둘 공간이 필요합니다.|


## Dynamic Programing

### 동적 계획법 알고리즘 구현 단계 
  
1. 문제를 하위 문제로 쪼갭니다.  
  
2. 하위 문제를 재귀적으로 해결합니다.  
  
3. 결과를 저장합니다. (메모이제이션)  
  
4. 저장된 결과를 이용하여 큰 문제를 해결합니다.  
**( 해당 단계를 통해서 중복 계산을 피하여서 성능을 높입니다.)**


### ** 메모이제이션(Memoization) 이란?**  
  
- 이전에 계산한 값을 저장하여 다시 계산하지 않도록 하여 속도를 빠르게 하는 방법입니다.

#### 1. 메모이제이션 구성 과정

> 1. 입력값에 대한 결과값을 저장할 메모이제이션 테이블을 초기화합니다.  
>   
> 2. 함수를 호출할 때, 먼저 메모이제이션 테이블에서 해당 입력값의 결과값이 이미 저장되어 있는지 확인합니다.  
>   
> 3. 저장되어 있으면 해당 결과값을 반환하고, 저장되어 있지 않으면 계산을 수행하고 그 결과를 메모이제이션 테이블에 저장합니다.계산된 결과값을 반환합니다.

> **[ 더 알아보기 ]**  
> **  
> 💡 메모이제이션 테이블이란?**  
>   
> - 동적 계획법에서 사용되는 저장 공간입니다. 이전에 계산한 값을 저장해두었다가 나중에 같은 값을 계산할 때 다시 계산하지 않고 이전에 계산한 값을 활용함으로써 계산 속도를 높일 수 있습니다.  
> - 일반적으로는 해시 테이블이나 배열 등을 사용하여 구현합니다.


> **💡 [참고] 피보나치 수열을 구하기 위한 계산법 : 메모이제이션 기법**  
>   
> **- 해당 방식은 메모이제이션 테이블에서 값이 검색되어 피보나치 수열의 계산 수행이 줄어들게 되는 방법입니다.  
> **  
> 1. 메모이제이션 테이블을 Map 자료형을 이용하여서 구현합니다.  
> 2. 이 때, n이 1 이하인 경우에는 n을 반환합니다. 그 외의 경우에는, 메모이제이션 테이블에서 해당 입력값의 결과값이 이미 저장되어 있는지 확인합니다.  
> 3. 저장되어 있으면 해당 결과값을 반환하고, 저장되어 있지 않으면 피보나치 수열의 값을 계산하여 결과를 메모이제이션 테이블에 저장한 후 반환합니다.

```java
import java.util.*;

public class MemoizationExample {
    private static Map<Integer, Integer> memo = new HashMap<>();

    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }

        if (memo.containsKey(n)) {
            return memo.get(n);
        }

        int result = fibonacci(n - 1) + fibonacci(n - 2);

        memo.put(n, result);

        return result;
    }

    public static void main(String[] args) {
        int n = 10;

        System.out.println("Fibonacci(" + n + ") = " + fibonacci(n));
    }
}
```


## 2) 동적 계획법의 조건

---

> 💡 동적 계획법을 사용하려면 다음의 조건을 만족해야합니다.

### [1. 최적 부분 구조 (Optimal Substructure)](https://adjh54.tistory.com/201#1.%20%EC%B5%9C%EC%A0%81%20%EB%B6%80%EB%B6%84%20%EA%B5%AC%EC%A1%B0%20(Optimal%20Substructure)-1)

---

> **💡 최적 부분 구조 (Optimal Substructure)이란?**  
>   
> **- '큰 문제의 최적해'가 '작은 문제의 최적해'를 포함하는 성질입니다.** 즉, 작은 문제의 최적해를 구한 후 그것을 이용하여 큰 문제의 최적해를 구할 수 있습니다.

### [2. 중복 부분 문제 (Overlapping Subproblems)](https://adjh54.tistory.com/201#2.%20%EC%A4%91%EB%B3%B5%20%EB%B6%80%EB%B6%84%20%EB%AC%B8%EC%A0%9C%20(Overlapping%20Subproblems)-1)

---

> **💡중복 부분 문제 (Overlapping Subproblems)란?  
> **  
> **- '동일한 작은 문제를 반복적으로 해결'해야 하는 성질입니다.** 즉, 작은 문제를 해결할 때 반복적으로 같은 문제를 해결해야 합니다.



## 이분탐색 

[이분탐색 참고 가이드 왕국에 건설할 금과 은 ](https://bellog.tistory.com/188) 

최솟값 + 최댓값 / 2 
중간값 